import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { SpecOperations } from "@spec-mcp/core";
import { z } from "zod";
import {
	formatDeleteResult,
	formatListResult,
	formatResult,
} from "../utils/result-formatter.js";
import { wrapToolHandler } from "../utils/tool-wrapper.js";
import type { ToolContext } from "./index.js";

// NOTE: These schemas are duplicated from @spec-mcp/data because:
// 1. @spec-mcp/data uses Zod v4
// 2. @spec-mcp/server uses Zod v3 (required by MCP SDK)
// 3. Zod v3 and v4 have incompatible types
// Source of truth remains in @spec-mcp/data - keep these in sync manually

// TaskSchema - matches TaskSchema from data package
const TaskIdSchema = z.string().regex(/^task-\d{3}$/);
const TaskPrioritySchema = z.enum(["critical", "high", "normal", "low", "optional"]);
const TaskSchema = z.object({
	id: TaskIdSchema,
	priority: TaskPrioritySchema.default("normal"),
	depends_on: z.array(TaskIdSchema).default([]),
	description: z.string().min(1),
	considerations: z.array(z.string()).default([]),
	completed: z.boolean().default(false),
});

// PlanPrioritySchema - matches PlanPrioritySchema from data package
const PlanPrioritySchema = z.enum(["critical", "high", "medium", "low"]);

// PlanIdSchema - matches PlanIdSchema from data package
const PlanIdSchema = z.string().regex(/^pln-\d{3}-[a-z0-9-]+$/);

/**
 * Register all plan-related tools
 */
export function registerPlanTools(
	server: McpServer,
	operations: SpecOperations,
	context: ToolContext,
) {
	// Create Plan Tool
	server.registerTool(
		"create-plan",
		{
			title: "Create Plan",
			description: "Create a new implementation plan",
			inputSchema: {
				slug: z.string().describe("URL-friendly identifier"),
				name: z.string().describe("Display name of the plan"),
				description: z.string().describe("Detailed description of the plan"),
				priority: PlanPrioritySchema
					.default("medium")
					.describe("Priority level"),
				acceptance_criteria: z
					.string()
					.describe("Conditions that must be met for the plan to be complete"),
				depends_on: z
					.array(PlanIdSchema)
					.optional()
					.describe("Other plan IDs this depends on"),
				tasks: z
					.array(TaskSchema)
					.optional()
					.describe("Implementation tasks"),
			},
		},
		wrapToolHandler(
			"create-plan",
			async ({
				slug,
				name,
				description,
				priority,
				acceptance_criteria,
				depends_on,
				tasks,
			}) => {
				const validatedSlug = context.inputValidator.validateSlug(slug);
				const validatedName = context.inputValidator.sanitizeString(name);
				const validatedDescription =
					context.inputValidator.sanitizeString(description);
				const validatedCriteria =
					context.inputValidator.sanitizeString(acceptance_criteria);

				// Note: `id`, `number`, and other computed fields are generated by the system
				const data = {
					type: "plan" as const,
					slug: validatedSlug,
					name: validatedName,
					description: validatedDescription,
					created_at: new Date().toISOString(),
					updated_at: new Date().toISOString(),
					priority,
					acceptance_criteria: validatedCriteria,
					depends_on: depends_on ?? [],
					tasks: tasks ?? [],
				};
				// @ts-expect-error - Type system limitation: system computes missing fields
				const result = await operations.createPlan(data);
				return formatResult(result);
			},
			context,
		),
	);

	// Get Plan Tool
	server.registerTool(
		"get-plan",
		{
			title: "Get Plan",
			description: "Retrieve a plan by its ID",
			inputSchema: {
				id: z.string().describe("Plan ID (e.g., 'pln-001-slug')"),
			},
		},
		wrapToolHandler(
			"get-plan",
			async ({ id }) => {
				const validatedId = context.inputValidator.validateId(id);
				const result = await operations.getPlan(validatedId);
				return formatResult(result);
			},
			context,
		),
	);

	// Update Plan Tool
	server.registerTool(
		"update-plan",
		{
			title: "Update Plan",
			description: "Update an existing plan",
			inputSchema: {
				id: z.string().describe("Plan ID to update"),
				name: z.string().optional().describe("Updated name"),
				description: z.string().optional().describe("Updated description"),
				priority: PlanPrioritySchema
					.optional()
					.describe("Updated priority"),
				acceptance_criteria: z
					.string()
					.optional()
					.describe("Updated acceptance criteria"),
				depends_on: z
					.array(PlanIdSchema)
					.optional()
					.describe("Updated plan dependencies"),
				tasks: z
					.array(TaskSchema)
					.optional()
					.describe("Updated tasks"),
			},
		},
		wrapToolHandler(
			"update-plan",
			async ({ id, ...updates }) => {
				const validatedId = context.inputValidator.validateId(id);

				const updateData: Record<string, unknown> = {
					updated_at: new Date().toISOString(),
				};

				if (updates.name) {
					updateData.name = context.inputValidator.sanitizeString(updates.name);
				}
				if (updates.description) {
					updateData.description = context.inputValidator.sanitizeString(
						updates.description,
					);
				}
				if (updates.acceptance_criteria) {
					updateData.acceptance_criteria =
						context.inputValidator.sanitizeString(updates.acceptance_criteria);
				}
				if (updates.priority) {
					updateData.priority = updates.priority;
				}
				if (updates.depends_on) {
					updateData.depends_on = updates.depends_on;
				}
				if (updates.tasks) {
					updateData.tasks = updates.tasks;
				}

				const result = await operations.updatePlan(validatedId, updateData);
				return formatResult(result);
			},
			context,
		),
	);

	// Delete Plan Tool
	server.registerTool(
		"delete-plan",
		{
			title: "Delete Plan",
			description: "Delete a plan by its ID",
			inputSchema: {
				id: z.string().describe("Plan ID to delete"),
			},
		},
		wrapToolHandler(
			"delete-plan",
			async ({ id }) => {
				const validatedId = context.inputValidator.validateId(id);
				const result = await operations.deletePlan(validatedId);
				return formatDeleteResult(result, "plan", validatedId);
			},
			context,
		),
	);

	// List Plans Tool
	server.registerTool(
		"list-plans",
		{
			title: "List Plans",
			description: "List all plans with optional filtering",
			inputSchema: {
				priority: PlanPrioritySchema
					.optional()
					.describe("Filter by priority"),
				completed: z
					.boolean()
					.optional()
					.describe("Filter by completion status"),
				search: z
					.string()
					.optional()
					.describe("Search in name and description"),
			},
		},
		wrapToolHandler(
			"list-plans",
			async ({ priority, completed, search }) => {
				const filter: Record<string, unknown> = {};
				if (priority) filter.priority = priority;
				if (completed !== undefined) filter.completed = completed;
				if (search) {
					filter.search = context.inputValidator.sanitizeString(search);
				}

				const result = await operations.listPlans(
					Object.keys(filter).length > 0 ? filter : undefined,
				);
				return formatListResult(result, "plan");
			},
			context,
		),
	);
}
